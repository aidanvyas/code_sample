"""
This was done on CodeSkulptor3 which was created by Scott Rixner.
"""

"""
The Kevin Bacon Game.

Replace "pass" with your code.
"""

import simpleplot
import comp140_module4 as movies
from collections import defaultdict

class Queue:
    """
    A simple implementation of a FIFO queue.
    """

    def __init__(self):
        """
        Initialize the queue.
        """
        
        self._items = []

    def __len__(self):
        """
        Returns: an integer representing the number of items in the queue.
        """
        
        return len(self._items)

    def __str__(self):
        """
        Returns: a string representation of the queue.
        """
        
        return str(self._items)

    def push(self, item):
        """
        Add item to the queue.

        input:
            - item: any data type that's valid in a list
        """
        
        self._items.append(item)

    def pop(self):
        """
        Remove the least recently added item.

        Assumes that there is at least one element in the queue.  It
        is an error if there is not.  You do not need to check for
        this condition.

        Returns: the least recently added item.
        """
        
        return self._items.pop(0)

    def clear(self):
        """
        Remove al`1l items from the queue.
        """
        
        self._items = []
        
    
def bfs(graph, start_node):
    """
    Performs a breadth-first search on graph starting at the
    start_node.

    inputs:
        - graph: a graph object
        - start_node: a node in graph representing the start node

    Returns: a two-element tuple containing a dictionary
    associating each visited node with the order in which it
    was visited and a dictionary associating each visited node
    with its parent node.
    """
    
    # This code was from the recipe provided to us.  
    # I realized that when in a dictionary, you can denote it using a subscript.
    # Additionally, I needed to use the graph functions at certain points which
    # wasn't very clear in the recipe.
    
    queue = Queue()
    dist = {}
    parent = {}
    
    for node in graph.nodes():
        dist[node] = float("inf")
        parent[node] = None
    
    dist[start_node] = 0
    queue.push(start_node)
    
    while len(queue) != 0:
        node = queue.pop()
        for nbr in graph.get_neighbors(node):
            if dist[nbr] == float("inf"):
                dist[nbr] = dist[node] + 1
                parent[nbr] = node
                queue.push(nbr)

    return dist, parent


def distance_histogram(graph, node):
    """
    Computes the distance between the given node and all other
    nodes in that graph and creates a histogram of those distances.

    inputs:
        - graph: a graph object
        - node: a node in graph

    returns: a dictionary mapping each distance with the number of
    nodes that are that distance from node.
    """
    
    # We create a new dictionary that has the values from the dist dictionary
    # from the above function.
    distance_map = defaultdict(int)
    bfs_import = bfs(graph, node)
    distance_import = bfs_import[0]
        
    # We iterate through the values of our dictionary, and we add 1 for each occurance.
    for distances in distance_import.values():
        distance_map[distances] += 1
        
    return distance_map
        
        
def find_path(graph, start_person, end_person, parents):
    """
    Computes the path from start_person to end_person in the graph.

    inputs:
        - graph: a graph oject with edges representing the connections between people
        - start_person: a node in graph representing the starting node
        - end_person: a node in graph representing the ending node
        - parents: a dictionary representing the parents in the graph

    returns a list of tuples of the path in the form:
        [(actor1, {movie1a, ...}), (actor2, {movie2a, ...}), ...]
    """
    
    path = []
        
    # At the end we add the last person, and because there's no path, we put 'set()'
    path.append((end_person, set()))
    
    # Iterates until end_person is not start_person
    while end_person is not start_person:
        
        # If you've reached a dead end, end the program
        if parents[end_person] == None:
            return []
        else:
            # Find the movie between the current / related actor
            movie = graph.get_attrs(end_person, parents[end_person])
            # Add the related actor / movie to the path
            path.append((parents[end_person], movie))
            # Set actor to the related actor
            end_person = parents[end_person]
    # I did this backwards, so as a quick fix, I switched it around.
    path.reverse()
    return path
  
        
def play_kevin_bacon_game(graph, start_person, end_people):
    """
    Play the "Kevin Bacon Game" on the actors in the given
    graph.

    inputs:
        - graph: a a graph oject with edges representing the connections between people
        - start_person: a node in graph representing the node from which the search will start
        - end_people: a list of nodes in graph to which the search will be performed

    Prints the results out.
    """
    
    # Iterates through all the people
    for end_person in end_people:
        # Assigns the parents from bfs to bfs_results
        bfs_results = bfs(graph, start_person)
        parents = bfs_results[1]
        # Gets the path
        path = find_path(graph, start_person, end_person, parents)
        # Prints the path â€“ function from the assignment sheet
        movies.print_path(path)
        
        
def run():
    """
    Load a graph and play the Kevin Bacon Game.
    """
    graph5000 = movies.load_graph('subgraph5000')

    if len(graph5000.nodes()) > 0:
        # You can/should use smaller graphs and other actors while
        # developing and testing your code.
        play_kevin_bacon_game(graph5000, 'Kevin Bacon',
            ['Amy Adams', 'Andrew Garfield', 'Anne Hathaway', 'Barack Obama', \
             'Benedict Cumberbatch', 'Chris Pine', 'Daniel Radcliffe', \
             'Jennifer Aniston', 'Joseph Gordon-Levitt', 'Morgan Freeman', \
             'Sandra Bullock', 'Tina Fey'])

        # Plot distance histograms
        for person in ['Kevin Bacon', 'Stephanie Fratus']:
            hist = distance_histogram(graph5000, person)
            simpleplot.plot_bars(person, 400, 300, 'Distance', \
                'Frequency', [hist], ["distance frequency"])

# Uncomment the call to run below when you have completed your code.

run()

